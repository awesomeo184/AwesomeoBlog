---
title: '[OS] 교착 상태(Deadlock)'
date: 2021-04-28 19:44:63
category: OS
thumbnail: { thumbnailSrc }
draft: false
---

# 교착상태(Deadlock)란?

정상적인 시스템에서 프로세스는 요청 → 사용 → 방출 순서로 자원을 사용한다.

* 요청: 프로세스는 자원을 요청한다. 요청이 즉시 처리되지 않는 경우(ex. 다른 프로세스가 해당 자원을 사용 중인 경우)
프로세스는 자원을 얻을 때까지 대기해야 한다.
* 사용: 자원에 대한 작업을 실행한다.
* 방출: 자원을 방출한다.

자원의 요청과 방출은 시스템 콜이다. 예시로는 디바이스의 request()와 release(),
파일의 open() 과 close(), 메모리의 allocate()와 free() 등이 있다.

OS가 관리하지 않는 자원의 요청과 방출은 세마포어에 대한 wait() & signal() 또는 뮤텍스 락의 획득과 방출을 통해서 이루어질 수 있다.

커널이 관리하는 자원을 프로세스가 사용할 때는 시스템 테이블이 어떤 프로세스가 어떤 자원을 사용 중이고, 대기 중인지 등 모든 사항을 기록한다.

만약 아래와 같이 임의의 프로세스 P1과 P2가 각각 자원 A, B를 점유한 채로 B, A를 사용하기 위해 대기 중이라면

![image](https://user-images.githubusercontent.com/63030569/116392948-0a685780-a85c-11eb-8a2f-6b1302f41b3a.png)

이때 두 프로세스는 교착 상태에 있다고 말한다. P1은 자원 B에 대한 요청이 처리될 때까지 A를 점유하고 있고, P2는 자원 A에 대한 요청이 처리될 때까지 B를 점유하고 있다.
결국 두 프로세스는 옴짝달싹 못한 채로 무한히 대기하게 된다.

## 교착상태의 필요 조건

교착 상태는 다음 네 가지 조건이 모두 만족할 때, **발생할 가능성**이 있다. 주의할 점은 네 가지 조건을 모두 만족할 때 반드시 일어나는 것이 아니라
발생할 가능성이 생기는 것이다.

1. 상호 배제(mutual exclusion): 최소 하나의 자원이 한 프로세스에 의해 상호 배제 상태로 점유되어야 한다.
2. 점유하며 대기(hold-and-wait): 프로세스는 최소 하나의 자원을 점유한 채로 다른 프로세스가 점유 중인 자원을 대기해야 한다.
3. 비선점(no preemption): 자원들을 선점할 수 없다. 즉 다른 프로세스가 점유 중인 자원을 강제로 뺏을 수 없고, 해당 프로세스가 자원을 자발적으로 방출할 때까지 기다리는 상태여야 한다.
4. 순환 대기(circular wait): 대기 중인 프로세스, 점유 당하고 있는 자원의 관계가 원형을 이루어야한다. 아래 그림 참조

![image](https://user-images.githubusercontent.com/63030569/116395113-a7c48b00-a85e-11eb-8499-cd750859e26f.png)

이때, 자원에서 프로세스로 향하는 간선(R → P)은 P가 R을 점유 중이라는 뜻이고
프로세스에서 자원으로 향하는 간선(P → R)은 P가 R을 대기 중이라는 뜻이다. 
프로세스는 동그라미, 자원은 네모로 나타낸다.
이렇게 자원과 프로세스의 관계를 그래프로 나타내는 것을 **자원 할당도(Resource Allocation Graph)**라고 한다.


# 교착상태 처리 방법

교착상태를 처리하는 데는 네 가지 방법이 있다.

1. 예방(Prevention)
2. 회피(Avoidance)
3. 검출 및 복구(Detection & Recovery)
4. 무시(Ignorance)

UNIX와 Windows를 포함한 대부분의 운영체제가 네 번째 방법을 사용한다. `교착상태 무시`란 말 그대로
교착상태에 대해 아무런 대응도 하지 않는 것이다. 교착상태는 자주 일어나지는 않는데다가 예방 및 처리에 비용이 많이 들기 때문에 이 방법은 꽤나 경제적일 수 있다
(만약 교착상태가 일어났다면 해당 프로세스를 강제 종료 후 재시작하면 된다^^).

사실 우리가 사용하는 운영체제(매우 정교하게 작성된!)의 커널 레벨에서 교착상태가 일어날 일은 거의 없다. 
보통 교착상태는 잘못 작성된 멀티스레드 어플리케이션에서 일어나는데, 이때 교착상태에 대한 책임은 응용 프로그램 개발자에게 있다.

그런데 교착상태를 무시해서는 안되는 경우가 있다. 예를 들어 우주 항공 산업에 쓰이는 시스템의 경우, 데드락이 한번이라도 일어나면 대참사가 일어날 수 있기 때문에 무시하고 넘어갈 수가 없다.

## 교착상태 예방

`교착상태 예방`은 앞서 살펴본 교착상태 필요조건 네 가지 중 적어도 하나가 성립하지 않도록 보장하는 일련의 방법들이다.

### Mutual Exclusion

자원에 대한 상호 배제를 인정하지 않음으로써 교착 상태를 예방하는 것이다. 읽기 전용 파일 등의 자원은 공유가 가능하기 때문에 교착 상태가 일어날 수가 없다.
근데 애초에 공유가 불가능한 자원이 존재할 수 있기 때문에 이 방법만으로 모든 교착상태를 예방하는 것은 불가능하다.

### Hold-and-Wait

프로세스가 자원을 요청하려면 다른 자원들을 가지고 있지 않다는 것을 보장함으로써 교착상태를 예방한다. 두 가지 프로토콜이 가능한데, 첫 번째 방법은
프로세스가 실행되기 전에 반드시 모든 자원을 요청하여 할당받게 하는 것이고, 두 번째는 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 강제하는 것이다.

두 번째 방법은 쉽게 이해가 가는데, 첫 번째 방법은 잘 이해가 가지 않을 수 있다. 예를 들어 설명하면 다음과 같다.

DVD 드라이브로부터 디스크 파일로 자료를 복사하여 디스크 파일을 정렬하고, 그 후에 프린터에 결과를 인쇄하는
프로세스가 있다고 생각해보자.

첫 번째 방식은, 프로세스가 시작할 때 DVD 드라이브, 디스크 파일, 프린터에 요청을 모두 보내는 것이다. 비록 
DVD 드라이브 → 디스크 파일 → 프린터 순으로 작업을 수행하지만 미리 요청을 해놓음으로써 다른 프로세스들이 점유하지 못하도록 하는 것이다.
반면 두 번째 방식은 DVD 드라이브를 사용하고나면 드라이브 자원을 모두 방출한 뒤 디스크 파일에 대한 요청을 하는 것이다.

이 방식의 단점은 자원 활용률이 저하되고 기아 상태가 발생할 수 있다는 점 등이 있다.

### No Preemption

자원을 선점 가능하게 한다. 즉 어떤 프로세스가 하나의 자원을 점유하고 있는 상태에서
즉시 할당할 수 없는 다른 자원(무조건 대기해야하는 자원)에 대해 요청을 하면, 현재 점유 중인 자원이 선점되게 하는 것이다.
이 역시 불가능한 상황이 존재한다. 예를 들어 프린터의 경우, 선점 당하면 하나의 페이지에 여러 프로세스의 작업이 프린트 될 수 있으므로
선점 당할 수 없는 자원에 해당한다.

### Circular Wait

환형 대기 조건은 자원에 순서를 매기고 그 순서대로 접근하도록 강제함으로써 차단할 수 있다.

예를 들어 뮤텍스 두 개에 대해 다음과 같이 고유의 정수 번호를 부여한다.

```
first_mutex = 1
second_mutex = 5
```

second_mutex에 대한 요청은 반드시 first_mutex를 획득한 뒤 이루어져야한다. 
이렇게 설정하면 아래와 같이 교착상태가 발생할 수 있는 코드 작성이 불가능해진다.

```C
/* thread_one runs in this function */
void *do_work_one(void *param)
{
    pthread_mutex_lock(&first_mutex);
    pthread_mutex_lock(&second_mutex);
    /*
    Do some work
    */
    pthread_mutex_unlock(&second_mutex);
    pthread_mutex_unlock(&first_mutex);
}

/* thread_two runs in this function */
void *do_work_two(void *param)
{
    pthread_mutex_lock(&second_mutex);
    pthread_mutex_lock(&first_mutex);
    /*
    Do some work
    */
    pthread_mutex_unlock(&first_mutex);
    pthread_mutex_unlock(&second_mutex);
}

```

## 교착상태 회피

`교착상태 회피`는 자원이 어떻게 요청될지에 대한 정보를 미리 파악하고 회피 알고리즘을 통해 교착 상태가 일어나지 않도록
자원을 할당하는 방식이다. 교착상태 예방은 교착상태가 발생할 수 있는 조건을 원천 차단하는 것이고,
교착상태 회피는 조건을 차단하는 것이 아니라, 정보를 미리 파악하고 교착상태가 일어나지 않는 방향으로 자원을 할당하는 것이다.

이는 교착상태 예방 방식에서 일어날 수 있는 이용률 저하와 처리율 감소를 피할 수 있다는 장점이 있다(회피 방식에 이용률 저하가 없다는 것은 아니다, 모든 방식은
각기 장단점이 있으며 상황에 맞는 최적의 방식을 구현해야한다).

